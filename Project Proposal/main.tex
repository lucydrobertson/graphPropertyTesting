%--------------------
% Packages
% -------------------
\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage{gentium}
\usepackage{mathptmx} % Use Times Font
\usepackage[style=alphabetic, maxbibnames=8]{biblatex}
\addbibresource{proposal.bib}

\usepackage[pdftex]{graphicx} % Required for including pictures
\usepackage[pdftex,linkcolor=black,pdfborder={0 0 0}]{hyperref} % Format links for pdf
\usepackage{calc} % To reset the counter in the document after title page
\usepackage{enumitem} % Includes lists

\frenchspacing % No double spacing between sentences
\linespread{1.2} % Set linespace
\usepackage[a4paper, lmargin=0.1666\paperwidth, rmargin=0.1666\paperwidth, tmargin=0.1111\paperheight, bmargin=0.1111\paperheight]{geometry} %margins
%\usepackage{parskip}

\usepackage[all]{nowidow} % Tries to remove widows
\usepackage[protrusion=true,expansion=true]{microtype} % Improves typography, load after fontpackage is selected

%-----------------------
% Begin document
%-----------------------
\begin{document} %All text i dokumentet hamnar mellan dessa taggar, allt ovanför är formatering av dokumentet
\title{Project Proposal}
\date{9th October 2024}
\author{Lucy Robertson, lr568}
\maketitle
\section{Introduction and Description}
This project will explore the area of property testing for graphs. Property testing is the solving of promise problems, often in sublinear time. In the context of property testing, a promise problem is a problem in which the input is promised to have some property, in which case the output should be yes, or is epsilon-far from having the property, in which case the output should be no. If the input neither has the property nor is epsilon-far from having the property then the tester can output yes or no. The tester has some error and it only outputs the answer expected above with some high probability.

This project will involve the implementation of multiple graph property testing algorithms in both the dense graphs model and bounded degree model for graph representation. The dense graphs model models graphs as an adjacency matrix, which for each possible vertex-vertex pair stores a boolean value indicating if there is an edge connecting those vertices. Analysis of graphs in this model is based on the graphs having \(O(n^2)\) edges. The bounded degree model is a model used for graphs in which all nodes are of a degree less than or equal to some chosen value, where we define the degree of a node as the number of edges that it is connected to. The bounded degree model represents graphs as incidence lists, which are lists that store up to d neighbour vertices for each vertex, where d is the maximum degree of a node in the graph.

Property testers are generally crafted to have a running time that is sublinear in the size of the input, so that the tester does not have to read the entire input before coming to a decision. It is desirable for testers to be proximity-oblivious, which means that they have a time complexity that does not depend on the size of the input. Such testers have a running time dependent solely on their error parameter \(\epsilon\), such as \(O(\frac{1}{\epsilon})\). The sublinear nature of property testers means that they are very useful for working with big data that cannot fit in the memory of a single processor.

The project will create a library of implementations of property testing algorithms, aiming to explore a range of algorithms and techniques common to property testing for the dense graphs and bounded degree graph models. The properties that will be tested in the dense graphs model are k-colourability, bipartiteness and degree regularity. \cite{goldreich} The properties that will be tested in the bounded degree model are k-colourability, bipartiteness \cite{Ron}, and cycle-freeness. The decision to choose some of the same properties to test across both models was taken to allow for evaluation of performance between the different algorithms on graphs of a similar size and/or number of edges. This will also allow for an exploration of the differences in testing properties between the two models. The inclusion of a property to be tested in one model and not in the other is to explore a greater range of strategies for property testing such as random walks, which are generally only used in the bounded degree model. 

I have chosen to create a library of property testing algorithm implementations as such algorithms can be quite simple, especially in the dense graphs model, and as such I am aiming to create sufficient complexity in the project through the inclusion of multiple different algorithms across the two models.

\section{Starting Point}
I have done some research on property testing in graphs, reading some surveys on the topic and the relevant chapters from Oded Goldreich’s book Introduction to Property Testing [1]. However, I have not started to implement any property testing algorithms, nor have I started on any of the other code that will be required for this project. I am proficient in Python which is the language I will be using, but I haven’t used any of its graphical libraries.

\section{Success Criteria}
The deliverables of this project include
\begin{enumerate}
    \item A library of property testing algorithms, including algorithms in both the dense and bounded degree graph models
    \item A class to generate graphs that have, are close to having, or are far from having each of the properties tested in the library
    \item An evaluation of each of the algorithms, examining their space and time complexity and their correctness. Each algorithm will be tested on graphs generated by the class above and its performance will be measured by the time taken to return an answer, and the correctness of the answer
\end{enumerate}

\section{Extensions}
\begin{itemize}
    \item Convert a real world graph (such as a social network graph) into a suitable model for the property testing algorithm to run, and run the tester on the graph
    \item Implement a multi-threaded version of the one of the property testers, based on the distributed property testing algorithms from \cite{censor}
    \item Implement a property testing algorithm in the general graphs model, the third graph model that can be used in property testing
    \item Improve on the time or query complexity of one of the property testing algorithms
    \item Implement some of the deterministic algorithms for each property that is tested in the library, to improve the evaluation of the property testers by providing a benchmark time to compare against along with a definitive answer
\end{itemize}

\section{Plan of Work}
Monday 21st October - Sunday 3rd November
\begin{itemize}
    \item Setup the IDE and work environment, including required libraries
    \item Build classes to represent graphs in both the dense graphs and bounded degree graph models
    \item Research the implementation of the property testing algorithms for the dense and bounded degree models
\end{itemize}
Monday 4th November - Sunday 17th November
\begin{itemize}
    \item Implement the three property testing algorithms in the dense graphs model
    \item test these implementations on small, manually created graphs
\end{itemize}
Milestone:  all algorithms in the dense graphs model are implemented \\
Monday 18th November - Sunday 1st December
\begin{itemize}
    \item Implement two property testing algorithms for the bounded degree model
    \item Test these implementations on small, manually created graphs
\end{itemize}
Monday 2nd December - Sunday 15th December
\begin{itemize}
    \item Implement the final property testing algorithm for the bounded degree model and test it on small, manually created graphs
    \item Create a graph generator that will create graphs that have, or are far from having the of the properties being tested
\end{itemize}
Milestone: aim number 1 of the success criteria delivered \\
Monday 16th December - Sunday 29th December
\begin{itemize}
    \item Expand the graph generator to create graphs that have or are far from having any one of the properties tested in the library
\end{itemize}
Milestone: aim number 2 of the success criteria delivered \\
Monday 30th December - Sunday 12th January
\begin{itemize}
    \item Slack period: Christmas holidays
    \item Catch up on any previously unfinished work
\end{itemize}
Monday 13th January - Sunday 26th January
\begin{itemize}
    \item Evaluate the library of property testing algorithms on graphs generated using the graph generator
\end{itemize}
Monday 27th January - Sunday 9th February
\begin{itemize}
    \item Continue evaluation of the property testing algorithms
    \item Work on possible extensions to the project
\end{itemize}
Milestone: aim number 3 of the success criteria delivered \\
Impediment: Progress report due Feb 7th \\
Monday 10th February - Sunday 23rd February
\begin{itemize}
    \item Continue work on possible extensions to the project
    \item Draft the “Evaluation” section of the dissertation and send to supervisor for comments
\end{itemize}
Monday 24th February - Sunday 9th March
\begin{itemize}
    \item Draft the “Introduction” and “Preparation” sections of the dissertation and send to supervisor for comments
\end{itemize}
Monday 10th March - Sunday 23rd March
\begin{itemize}
    \item Draft the “Implementation” section of the dissertation and send to supervisor for comments
\end{itemize}
Monday 24th March - Sunday 6th April
\begin{itemize}
    \item Draft the “Conclusion” section of the dissertation and send to supervisor for comments
\end{itemize}
Monday 7th April - Sunday 11th May
\begin{itemize}
    \item Wait on supervisor comments
    \item Edit and improve dissertation according to supervisors comments
    \item Submit dissertation: deadline is 16th May
\end{itemize}

\section{Resource Declaration}
I will be using my own computer for the project which is an ASUS ZenBook with 16GB RAM and an Intel® Core™ i7-1065G7 CPU @ 1.30GHz × 8. If this machine were to fail, I have sufficient funds to purchase a new one. 
I accept full responsibility for this machine and I have made contingency plans to protect myself against hardware and/or software failure.
I will be backing the code for the project up to github daily, along with keeping a local copy on my machine. I will be using Overleaf to write my dissertation which integrates with github to store my dissertation in an online repository. I will also keep an updated local copy of my dissertation.

\printbibliography
\end{document}
